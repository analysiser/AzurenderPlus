\documentclass[a4paper, oneside, 10pt]{article}
\usepackage{float}
\usepackage{amsfonts} % if you want blackboard bold symbols e.g. for real numbers
\usepackage{graphicx} % if you want to include jpeg or pdf pictures
\usepackage{listings} % entering code.
\graphicspath{ {images/} }

\title{{\bf 15-418 Final Project Report \\
 \large Solving Out of Core Ray Tracing Problem by a Distributed Path Tracing System}} % change this

\author{Xiao Li (xiaol2) and Yihua Eric Fang (yihuaf)}

\date{\today} % change this

\begin{document}

%%%%%%%%%% PRELIMINARY MATERIAL %%%%%%%%%%
\maketitle
\thispagestyle{empty}
\newpage
\begin{center}
\vspace*{\fill}
\section*{Abstract}
Parallel Breadth-First Search, from the past to present.\\
\vspace*{\fill}
\newpage
\end{center}

\tableofcontents
\newpage

%%%%%%%%%% MAIN TEXT STARTS HERE %%%%%%%%%%
\section{Introduction}
\section{Background}
\paragraph{} In general, the renderers used in animation, film or FX industries could be categorized as on-core and out-of-core renderers.  In the context of ray tracer, on core ray tracer ensures the whole scene to render fits in the DRAM of a machine. This allows the ray tracer to generate random numbers of rays when intersection happens, and trace them without worrying about scheduling the loading and unloading scenes. 

\paragraph{} Out-of-core renderers, on the other hand, assumes the scenes are too big to fit in the DRAM of a single machine. One of the major benefits of out-of-core renderers is they have no hard upper limits on geometries to render. However, usually the out-of-core renderers need to take extra efforts for scheduling the ray tracing system, manage the geometries workload balancing across machines, perform extra work reduction, optimization of memory coherence and hide all kinds of communication latency. 

\paragraph{} We designed a system to perform out-of-core rendering, based on Azurender, a ray tracing based renderer. We designed and implemented two algorithms. Different from the design of Hyperion or Pantaray, which are more focused on smarter sorting, loading and unloading of rays, ray packets or BVHs to hide the latency caused by hard disk accessing, our design load the scenes into DRAMs in a distributed system and focus on the scheduling and optimization for inter-machine communications. 

\section{System Design}
\subsection{System Overview}
\subsubsection{Ray Tracing System}
\paragraph{} Our system involves a basic ray tracing logic, as shown in the $Figure 1$. Like any other ray tracing system, if we do not generate second rays at all, it would have direct illumination only. For simplicity, we assumed all second rays intersection would be a lambertian diffusive surface hit.
\\
\includegraphics[width=\textwidth] {img1}


\subsection{Approach 1 - Staged}
\subsubsection{Overview}
\paragraph{}The first approach is a stage by stage algorithm. The idea behind it is to take the advantage of distributed machines across the network. Each of the ray tracing stage is separated. Each of the nodes (machines) in the system performs the exact same operations at the same stage. After each stage, there would be a synchronized blocking communication in between machines for exchanging the required data for next stage. The data would be duplicated across machines. For example, if one eye ray hits multiple root level bounding boxes of different nodes, the eye ray would be duplicated and sent to multiple machines. 
After the stage of tracing and when comes to the stage of shading, each machine / node would update their own local frame buffer, depth buffer and shadow map. Then a gather operations is performed on root node, and framebuffer information from different nodes would be merged.
The system is shown in [Figure No.].
\paragraph{}The assumption behind it is that local ray tracing and shading is fast and cheap and inter-nodes communication is expensive, meanwhile, Open MPI is optimized for large chunk of data exchange. The design assumes that the overhead of increased replicated work is lower than the overhead of increased communication.
\subsubsection{Work Flow}
\subsection{Approach 2 - Asynchronous}
\subsubsection{Overview}
\subsubsection{Work Flow}
\paragraph{} Below is the code that drives the main infinite loop of both the master and the slaves. Each node, master and slaves, maintains a work queue and a result list. The work queue contains the rays that have not yet to be processed by the node. The result list contains the already processed rays which are to be distributed to other nodes for processing. The master and slaves would start by draining the rays inside the work queue and process them respectively as master and slaves. Master and slaves have different logic in processing the ray, which we will discuss in details later.  Each node, after finished processing the rays in their work queue and stored into the result list, would send the rays in the result lists to the correct nodes in batch. This is done through $exchange\_ray()$ function. After receiving new rays from other nodes, these rays are put into the work queue for next iteration. Then, each node would ask all nodes in the system for the number of work in their work queue. If all nodes has no work, then each node can safely terminate.
 \lstset{language=C++} 
 \begin{lstlisting}[frame=single] 
void azMPI::run()
 {
    bool finish = false;
    while(!finish)
    {
        if (procId == 0)
        {
            master_process_ray();
        }
        else
        {
            slave_process_ray();
        }
        exchange_ray();
        finish = exchange_workload();
    }
 }
 
\end{lstlisting}

\subsubsection{Data Communicated}
\paragraph{} 
\subsubsection{Processing Rays}
\paragraph{} The main job for the master is to update the frame buffer as rays are finished processing by the slaves. Below is the pseudo specifying the master's operations.
 \begin{lstlisting}[frame=single] 
    void azMPI::master_process_ray()
    {
        while(!wait_queue.empty())
        {
            Ray &recv_r = wait_queue.front();
            switch(ray_type)
            {
                case ERayType_Eye:
                    updateFrameBuffer();
                    break;
                case ERayType_Shadow:
                    updateFrameBuffer();
                    break;
                case ERayType_GIShadow:
                    updateFrameBuffer();
                    break;
                case ERayType_GI:
                    break;
                default:
                    exit(-1);
            }
            wait_queue.pop();
        }
    }
 
\end{lstlisting}
\subsubsection{Hopping Algorithm}
\paragraph{} One drawbacks of the first approach is the duplicated processing of rays across machine resulting in duplicated works when rays hit multiple bounding boxes. To be specific, in the current design of the system, since model are distributed on each nodes, a ray can potentially hit multiple bounding boxes if the models are close together but on different nodes.  In the first approach, when a ray hits multiple bounding boxes, the ray is sent to multiple node for tracing ans shading independently. This solution not only resulted in extra work in the tracing and shading, it also caused several other issues.
\paragraph{} The first is that the system would need extra state information to decide how to combine the shading results from multiple nodes together into the frame buffer. As mentioned in the above, a depth buffer and a shadow map is required to correctly combine the shading results from multiple machines. 
\paragraph{} The second problem is the duplication of second rays or global illumination rays. For example, when an eye ray hit multiple bounding boxes, it is sent to multiple nodes for processing. Following the ray tracing algorithm, when an eye ray hits a surface, it generates a shadow ray and some number of global illumination rays. In this case, when the eye ray is sent to multiple nodes, each nodes after processing and shading would generate a shadow ray and global illumination rays. However, among all these second rays generated, only one set is actually valid. All the other rays' work would be wasted. In addition, when the depth of global illumination rays gets large, the number of wasted work would grow exponentially. 
\paragraph{} In order to resolve this problem, we devised the following algorithm in processing the rays for the asynchronous system.  Unlike the staged approach, this asynchronous approach allows the rays at each stage to go through multiple iterations since the asynchronous approach is not defined by stages but by iterations.
\paragraph{} The algorithm we devised is quite similar to a single thread ray tracing, but with a tweak, it works on distributed settings as well.  In a single thread ray tracing system, a ray is traced by traversing the BVH tree. Each time during the traversal when a ray hits a surface, a time value $t$ is updated for the ray and the hit surface.  The traversal would continue to other branch of the BVH where the ray also hits the bounding box of the branch, but it can potentially be pruned if the subbranch has $t$ value greater than the existing $t$ value. Our algorithm on the distributed settings mimics this single threaded algorithm.
\paragraph{} First, we devised a strict ordering between nodes using node ID in an increasing order, given node ID is unique across the system. If a ray hits multiple bounding boxes, the ray is always first sent to the node with one of the bounding boxes who has the lowest node ID for processing.  After tracing at the node, the ray would be sent to the node with the next lowest node ID for processing, but with a new time $t$ generated by the tracing on this node. The next node, when tracing the ray, can use this $t$ value to eliminate a large amount of work in tracing. If there is no node bounding boxes with a higher ID that intersects the ray, the ray is considered done and to be sent to master for updating the frame buffer and shadow rays or global illumination rays are generated if needed.  For example, if a ray hits the bounding box of node 0, 2, and 4, the ray would be first sent to node 0, then node 2 and finally node 4. At node 4, it sees that no other node with bounding boxes that intersect with this ray and a higher node ID, it considers the ray to be done.
\paragraph{} In this way, the system remains stateless and only generates rays that are needed.

\subsubsection{Future Optimization}
\section{Result}

%%%%%%%%%% BIBLIOGRAPHY %%%%%%%%%%


\bibliographystyle{plain}
\bibliography{references}
\addcontentsline{toc}{section}{References}

\end{document}